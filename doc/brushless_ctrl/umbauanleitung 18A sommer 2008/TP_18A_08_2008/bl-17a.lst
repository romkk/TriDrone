
AVRASM ver. 2.1.9  D:\proj\ARM7\armufo\Mag8\seriell\umbauanleitung 18A sommer 2008\TP_18A_08_2008\bl-17a.asm Wed Dec 03 12:08:23 2008

D:\proj\ARM7\armufo\Mag8\seriell\umbauanleitung 18A sommer 2008\TP_18A_08_2008\bl-17a.asm(33): Including file 'C:\Programme\Atmel\AVR Tools\AvrAssembler2\Appnotes\m8def.inc'
D:\proj\ARM7\armufo\Mag8\seriell\umbauanleitung 18A sommer 2008\TP_18A_08_2008\bl-17a.asm(34): Including file 'D:\proj\ARM7\armufo\Mag8\seriell\umbauanleitung 18A sommer 2008\TP_18A_08_2008\bl-17a.inc'
D:\proj\ARM7\armufo\Mag8\seriell\umbauanleitung 18A sommer 2008\TP_18A_08_2008\bl-17a.asm(45): Including file 'D:\proj\ARM7\armufo\Mag8\seriell\umbauanleitung 18A sommer 2008\TP_18A_08_2008\m12\mnum.inc'
                 
                 
                 ;
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 ;
                 ;1. Da ich alles kostenlos zur Verfügung stelle, gebe ich keinerlei Garantie
                 ;   und übernehme auch keinerlei Haftung für die Folgen der Benutzung.
                 ;
                 ;2. Die Software ist ausschließlich zur privaten Nutzung bestimmt. Ich
                 ;   habe nicht geprüft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                 ;   verletzt werden oder sonstige rechtliche Einschränkungen vorliegen.
                 ;
                 ;3. Jeder darf Änderungen vornehmen, z.B. um die Funktion seinen Bedürfnissen
                 ;   anzupassen oder zu erweitern. Ich würde mich freuen, wenn ich weiterhin als
                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                 ;   (falls vorhanden) mitgeteilt wird.
                 ;
                 ;4. Auch nach den Änderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                 ;
                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                 ;
                 ; Dezember 2006
                 ; autor: Bernhard Konze
                 ; email: bernhard.konze@versanet.de
                 ; minor changes: Oct 2007, Hans Haider, h.haider@comdesign.at - marked with #HH#
                 ;
                 ;**** **** **** **** ****
                 ; Device
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 ; z.Z. Nur für den Kaufregler BL17A-3P mit 16 MHz geeignet
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 .include "m8def.inc"
                 
                 ;***** Created: 2006-10-03 09:16 ******* Source: ATmega8.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m8def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega8
                 ;* Date              : 2006-10-03
                 ;* Version           : 2.24
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega8
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M8DEF_INC_
                 #define _M8DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega8
                 #pragma AVRPART ADMIN PART_NAME ATmega8
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCL	= 0x04
                 .equ	ADCH	= 0x05
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 
                 ; TCCR0 - Timer/Counter0 Control Register
                 .equ	CS00	= 0	; Clock Select0 bit 0
                 .equ	CS01	= 1	; Clock Select0 bit 1
                 .equ	CS02	= 2	; Clock Select0 bit 2
                 
                 ; TCNT0 - Timer Counter 0
                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Waveform Genration Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEWEE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PUD	= 2	; Pull-up Disable
                 .equ	ADHSM	= 4	; ADC High Speed Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADFR	= 5	; ADC  Free Running Select
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	WTDON	= 6	; Enable watchdog
                 .equ	RSTDISBL	= 7	; Disable reset
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x045f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _M8DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 .include "bl-17a.inc"
                 
                 ;* BL-17A                                                  *
                 ;* Dez.2006
                 ;* http://home.versanet.de/~b-konze/                       *
                 ;*********************************************************** 
                 ; minor changes: Oct 2007, Hans Haider, h.haider@comdesign.at - marked with #HH#
                 ;*********************************************************** 
                 
                 #define Typ "tp-esc18"
                 
                 .equ CPU_FREQ = 16
                 
                 ; activate Motor brake 
                 
                 .equ MOT_BRAKE      = 0
                 
                 .equ	DEBUG_LEDS = 0
                 
                 
                 ;**** **** **** **** ****
                 ; PORT  definitions
                 ;**** **** **** **** ****
                 
                 ;*********************
                 ; PORT D 
                 ;*********************  
                 .equ	BpFET		= 7	;o
                 .equ	c_comp		= 6	;i common comparator input (AIN0)
                 .equ	ApFET		= 5	;o
                 .equ	CpFET		= 4	;o
                 .equ	CnFET		= 3	;o
                 .equ	rcp_in		= 2	;i r/c pulse input
                 .equ	BnFET		= 1	; #HH#
                 ;.equ			= 0	;
                 .equ	INIT_PD		= 0b00000001
                 
                 .equ	DIR_PD		= (1<<BpFET)+(1<<CpFET)+(1<<BnFET)+(1<<CnFET)+(1<<ApFET)
                 .equ	BRAKE_PD	= (1<<BnFET)+(1<<CnFET)
                 
                 #define BpFET_on	sbi	PORTD,7
                 #define BpFET_off	cbi	PORTD,7
                 #define ApFET_on	sbi	PORTD,5
                 #define ApFET_off	cbi	PORTD,5
                 #define CpFET_on	sbi	PORTD,4
                 #define CpFET_off	cbi	PORTD,4
                 #define CnFET_on	sbi	PORTD,3
                 #define CnFET_off	cbi	PORTD,3
                 #define BnFET_on	sbi	PORTD,1
                 #define BnFET_off	cbi	PORTD,1
                 #define AnFET_on	sbi	PORTC,0
                 #define AnFET_off	cbi	PORTC,0
                 
                 
                 ;*********************
                 ; PORT C definitions *
                 ;*********************
                 .equ	AnFET		= 0	; o
                 ;.equ	ApFET		= 1	; o 
                 .equ	mux_a		= 2	; ADC2 phase input
                 .equ  mux_b  	= 3     ; ADC3 phase input 
                 .equ	mux_c		= 4	; ADC4 phase input (SDA)
                 ;.equ    	  	= 5	; ADC5 SCL
                 
                 ;*********************
                 ; ADC only
                 ;*********************
                 ;.equ    	  	= 6	; ADC6
                 .equ 	ACCU_MUX	= 7 	; ADC7 voltage control input 
                 
                 .equ	INIT_PC		= 0 ; #HH# (1<<AnFET)
                 .equ	DIR_PC		= (1<<AnFET) ; #HH#
                 .equ	BRAKE_PC	= (1<<AnFET)
                 
                 
                 ;*********************
                 ; PORT B definitions *
                 ;*********************
                 ;.equ		= 7	
                 ;.equ		= 6	
                 ;.equ		= 5    	; (sck stk200 interface) 
                 ;.equ		= 4	; (miso stk200 interface)
                 ;.equ   SPI_MOSI	= 3	; (mosi stk200 interface) 
                 ;.equ		= 2	; (ss for spi control)
                 ;.equ	SPI_SS	= 1	
                 ;.equ		= 0	; connected with pb4 ???	
                 
                 #define HHDEBUGLED_on  sbi PORTB,1 ; #HH# LED at pin 13 of atmega8
                 #define HHDEBUGLED_off cbi PORTB,1 ; #HH# LED at pin 13 of atmega8
                 .equ	INIT_PB		= 0
                 .equ	DIR_PB		= (1<<2) + (1<<1)	; PB2=0 - whyever ;-)   PB1=debugled #HH#
                 
                 .equ	BRAKE_PB	= 0
                 
                 ;
                 ; 8K Bytes of In-System Self-Programmable Flash
                 ; 512 Bytes EEPROM
                 ; 1K Byte Internal SRAM
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 ; fuses must be set to internal calibrated oscillator = 8 mhz
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 
                 .include "mnum.inc"
                 
                 
                 .equ	CHANGE_TIMEOUT	= 0x01
                 .equ	CHANGE_TOT_LOW	= 0x01
                 
                 ;.equ	POWER_RANGE	= 200			; full range of tcnt0 setting 10kHz
                 .equ	POWER_RANGE	= 125			; full range of tcnt0 setting 16kHz
                 ;.equ	POWER_RANGE	= 100			; full range of tcnt0 setting 20kHz
                 ;.equ	MIN_DUTY	= 15			; no power 10kHz
                 .equ	MIN_DUTY	= 14			; no power 16kHz
                 ;.equ	MIN_DUTY	= 13			; no power 20kHz
                 .equ	NO_POWER	= 256-MIN_DUTY		; (POWER_OFF)
                 .equ	MAX_POWER	= 256-POWER_RANGE	; (FULL_POWER)
                 
                 .equ	PWR_MAX_RPM1	= POWER_RANGE/4
                 .equ	PWR_MAX_RPM2	= POWER_RANGE/2
                 
                 ;.equ	PWR_STARTUP	= 40			; startup power 10kHz
                 ;.equ	PWR_MAX_STARTUP	= PWR_STARTUP+20
                 .equ	PWR_STARTUP	= 20			; startup power 16kHz ; bko: 25
                 .equ	PWR_MAX_STARTUP	= PWR_STARTUP+13
                 ;.equ	PWR_STARTUP	= 20			; startup power 20kHz
                 ;.equ	PWR_MAX_STARTUP	= PWR_STARTUP+10
                 
                 
                 .equ	timeoutSTART	= 65000
                 .equ	timeoutMIN		= 48000
                 
                 .equ	T1STOP	= 0x00
                 .equ	T1CK8	= 0x02
                 
                 ; timing(-l-h-x) holds the time of 4 commutations
                 ; e.g.: timing = 0x010000 = 65536 * 0.5µs (timer1)
                 ; 1 commutation = 8192µs
                 ; 1/RPS (round per secone) = 6 commutations = 49152µs
                 ; RPS = 20,34 ==> RPM = 1221
                 ; PWR_RANGEx refers to timing_h if (timing_x==0)
                 ;.equ	PWR_RANGE1	= 0x80	; ( ~2400 RPM )
                 ;.equ	PWR_RANGE2	= 0x40	; ( ~4800 RPM )
                 .equ	PWR_RANGE1	= 0xc0	; ( ~1800 RPM )
                 .equ	PWR_RANGE2	= 0x80	; ( ~2400 RPM )
                 
                 .equ	ENOUGH_GOODIES	= 60
                 
                 ;**** **** **** **** ****
                 ; Register Definitions
                 .def	i_sreg		 = r1	; status register save in interrupts
                 .def	tcnt0_power_on	 = r2	; timer0 counts nFETs are switched on
                 .def	tcnt0_change_tot = r3	; when zero, tcnt0_power_on is changed by one (inc or dec)
                 .def	byte_cnt	 = r4
                 .def	uart_cnt	 = r5
                 .def	tcnt0_pwron_next = r6
                 
                 .def	start_rcpuls_l	 = r7
                 .def	start_rcpuls_h	 = r8
                 .def	motor_count 	 = r9
                 ;.def	motor_total = r10 ;
                 .def	control_timeout	 = r11
                 ;.equ	CONTROL_TOT	 = 50	; time = NUMBER x 65ms
                 .equ	CONTROL_TOT	 = 4	; time = NUMBER x 65ms
                 
                 .def	current_err	 = r12	; counts consecutive current errors
                 .equ	CURRENT_ERR_MAX  = 3	; performs a reset after MAX errors
                 
                 .def	sys_control	 = r13
                 .def	t1_timeout	 = r14
                 .def	run_control	 = r15
                 
                 
                 .def	temp1	= r16			; main temporary
                 .def	temp2	= r17			; main temporary
                 .def	temp3	= r18			; main temporary
                 .def	temp4	= r19			; main temporary
                 
                 .def	i_temp1	= r20			; interrupt temporary
                 .def	i_temp2	= r21			; interrupt temporary
                 .def	i_temp3	= r22			; interrupt temporary
                 
                 .def	flags0	= r23	; state flags
                 	.equ	OCT1_PENDING	= 0	; if set, output compare interrunpt is pending
                 	.equ	UB_LOW 		= 1	; set if accu voltage low
                 	.equ	I_pFET_HIGH	= 2	; set if over-current detect
                 	.equ	GET_STATE	= 3	; set if state is to be send
                 	.equ	C_FET		= 4	; if set, C-FET state is to be changed
                 	.equ	A_FET		= 5	; if set, A-FET state is to be changed
                 	     ; if neither 1 nor 2 is set, B-FET state is to be changed
                 	.equ	I_OFF_CYCLE	= 6	; if set, current off cycle is active
                 	.equ	T1OVFL_FLAG	= 7	; each timer1 overflow sets this flag - used for voltage + current watch
                 
                 .def	flags1	= r24	; state flags
                 	.equ	POWER_OFF	= 0	; switch fets on disabled
                 	.equ	FULL_POWER	= 1	; 100% on - don't switch off, but do OFF_CYCLE working
                 	.equ	CALC_NEXT_OCT1	= 2	; calculate OCT1 offset, when wait_OCT1_before_switch is called
                 	.equ	RC_PULS_UPDATED	= 3	; new rc-puls value available
                 	.equ	EVAL_SYS_STATE	= 4	; if set, overcurrent and undervoltage are checked
                 	.equ	EVAL_RPM	= 5	; if set, next PWM on should look for current
                 	.equ	EVAL_PWM	= 6	; if set, PWM should be updated
                 
                 .def	flags2	= r25
                 	.equ	RPM_RANGE1	= 0	; if set RPM is lower than 1831 RPM
                 	.equ	RPM_RANGE2	= 1	; if set RPM is between 1831 RPM and 3662 RPM
                 	.equ	SCAN_TIMEOUT	= 2	; if set a startup timeout occurred
                 	.equ	POFF_CYCLE	= 3	; if set one commutation cycle is performed without power
                 	.equ	COMP_SAVE	= 4	; if set ACO was high
                 	.equ	STARTUP		= 5	; if set startup-phase is active
                 	.equ	RC_INTERVAL_OK	= 6	; 
                 	.equ	NO_SYNC		= 7	; 
                 
                 ; here the XYZ registers are placed ( r26-r31)
                 
                 ; ZH = new_duty		; PWM destination
                 
                 
                 ;**** **** **** **** ****
                 ; RAM Definitions
                 .dseg					;EEPROM segment
                 .org SRAM_START
                 
000060           tcnt1_sav_l:	.byte	1	; actual timer1 value
000061           tcnt1_sav_h:	.byte	1
000062           last_tcnt1_l:	.byte	1	; last timer1 value
000063           last_tcnt1_h:	.byte	1
000064           timing_l:	.byte	1	; holds time of 4 commutations 
000065           timing_h:	.byte	1
000066           timing_x:	.byte	1
                 
000067           timing_acc_l:	.byte	1	; holds the average time of 4 commutations 
000068           timing_acc_h:	.byte	1
000069           timing_acc_x:	.byte	1
                 
00006a           rpm_l:		.byte	1	; holds the average time of 4 commutations 
00006b           rpm_h:		.byte	1
00006c           rpm_x:		.byte	1
                 
00006d           wt_comp_scan_l:	.byte	1	; time from switch to comparator scan
00006e           wt_comp_scan_h:	.byte	1       
00006f           com_timing_l:	.byte	1	; time from zero-crossing to switch of the appropriate FET
000070           com_timing_h:	.byte	1
000071           wt_OCT1_tot_l:	.byte	1	; OCT1 waiting time
000072           wt_OCT1_tot_h:	.byte	1
000073           zero_wt_l:	.byte	1
000074           zero_wt_h:	.byte	1
000075           last_com_l:	.byte	1
000076           last_com_h:	.byte	1
                 
000077           stop_rcpuls_l:	.byte	1
000078           stop_rcpuls_h:	.byte	1
000079           new_rcpuls_l:	.byte	1
00007a           new_rcpuls_h:	.byte	1
                 
00007b           duty_offset:	.byte	1
00007c           goodies:	.byte	1
00007d           comp_state:	.byte	1
00007e           uart_command:	.byte	1
                 
00007f           uart_data:	.byte	100		; only for debug requirements
                 
                 
                 ;**** **** **** **** ****
                 ; ATmega8 interrupts
                 
                 ;.equ	INT0addr=$001	; External Interrupt0 Vector Address
                 ;.equ	INT1addr=$002	; External Interrupt1 Vector Address
                 ;.equ	OC2addr =$003	; Output Compare2 Interrupt Vector Address
                 ;.equ	OVF2addr=$004	; Overflow2 Interrupt Vector Address
                 ;.equ	ICP1addr=$005	; Input Capture1 Interrupt Vector Address
                 ;.equ	OC1Aaddr=$006	; Output Compare1A Interrupt Vector Address
                 ;.equ	OC1Baddr=$007	; Output Compare1B Interrupt Vector Address
                 ;.equ	OVF1addr=$008	; Overflow1 Interrupt Vector Address
                 ;.equ	OVF0addr=$009	; Overflow0 Interrupt Vector Address
                 ;.equ	SPIaddr =$00a	; SPI Interrupt Vector Address
                 ;.equ	URXCaddr=$00b	; USART Receive Complete Interrupt Vector Address
                 ;.equ	UDREaddr=$00c	; USART Data Register Empty Interrupt Vector Address
                 ;.equ	UTXCaddr=$00d	; USART Transmit Complete Interrupt Vector Address
                 ;.equ	ADCCaddr=$00e	; ADC Interrupt Vector Address
                 ;.equ	ERDYaddr=$00f	; EEPROM Interrupt Vector Address
                 ;.equ	ACIaddr =$010	; Analog Comparator Interrupt Vector Address
                 ;.equ	TWIaddr =$011	; Irq. vector address for Two-Wire Interface
                 ;.equ	SPMaddr =$012	; SPM complete Interrupt Vector Address
                 ;.equ	SPMRaddr =$012	; SPM complete Interrupt Vector Address
                 ;-----bko-----------------------------------------------------------------
                 
                 ;**** **** **** **** ****
                 .cseg
                 .org 0
                 ;**** **** **** **** ****
                 
                 ;-----bko-----------------------------------------------------------------
                 ; reset and interrupt jump table
000000 c01c      		rjmp	reset
000001 0000      		nop	; ext_int0
000002 0000      		nop	; ext_int1
000003 0000      		nop	; t2oc_int
000004 0000      		nop	; t2ovfl_int
000005 0000      		nop	; icp1
000006 c06a      		rjmp	t1oca_int
000007 0000      		nop	; t1ocb_int
000008 c06c      		rjmp	t1ovfl_int
000009 c077      		rjmp	t0ovfl_int
00000a 0000      		nop	; spi_int
00000b c0bf      		rjmp	urxc
00000c 0000      		nop	; udre
00000d 0000      		nop ; utxc ; #HH# not used - only receiver in action!
                 ; not used	nop	; adc_int
                 ; not used	nop	; eep_int
                 ; not used	nop	; aci_int
                 ; not used	nop	; wire2_int
                 ; not used	nop	; spmc_int
                 
                 
00000e 0a0d      version:	.db	0x0d, 0x0a
00000f 6b62
000010 7074
000011 652d
000012 6373
000013 3831
000014 3134
000015 7230
000016 3630
000017 3470
000018 2d30
000019 6175
00001a 7472
00001b 3630      		.db	"bk",Typ,"410r06p40-uart06"
00001c 0a0d      		.db	0x0d, 0x0a
                 
                 ;-----bko-----------------------------------------------------------------
                 ; init after reset
                 
00001d e004      reset:		ldi	temp1, high(RAMEND)	; stack = RAMEND
00001e bf0e      		out	SPH, temp1
00001f e50f      		ldi	temp1, low(RAMEND)
000020 bf0d      		out 	SPL, temp1
                 
                 	; runs with 16MHz crystal - no calibration needed
                 
                 	; portB
000021 e000      		ldi	temp1, INIT_PB
000022 bb08      		out	PORTB, temp1
000023 e006      		ldi	temp1, DIR_PB
000024 bb07      		out	DDRB, temp1
                 
                 	; portC
000025 e000      		ldi	temp1, INIT_PC
000026 bb05      		out	PORTC, temp1
000027 e001      		ldi	temp1, DIR_PC
000028 bb04      		out	DDRC, temp1
                 
                 	; portD
000029 e001      		ldi	temp1, INIT_PD
00002a bb02      		out	PORTD, temp1
00002b eb0a      		ldi	temp1, DIR_PD
00002c bb01      		out	DDRD, temp1
                 		
00002d 9ac1      		HHDEBUGLED_on
                 
                 	; timer0: PWM + beep control = 0x02 	; start timer0 with CK/8 (0.5µs/count)
00002e e002      		ldi	temp1, 0x02
00002f bf03      		out	TCCR0, temp1
                 
                 	; timer1: commutation control = 0x02	; start timer1 with CK/8 (0.5µs/count)
000030 e002      		ldi	temp1, T1CK8
000031 bd0e      		out	TCCR1B, temp1
                 
                 	; reset state flags
000032 2777      		clr	flags0
000033 2788      		clr	flags1
000034 2799      		clr	flags2
                 
000035 e00c      		ldi	temp1, MOTOR_NUMBER
000036 2e90      		mov	motor_count, temp1
000037 6890      		sbr	flags2, (1<<NO_SYNC)
                 		
                 	; clear RAM
000038 27bb      		clr	XH
000039 e6a0      		ldi	XL, low (SRAM_START)
00003a 2700      		clr	temp1
00003b 930d      clear_ram:	st	X+, temp1
00003c 38a0      		cpi	XL, uart_data+1
00003d f3e8      		brlo	clear_ram
                 
                 	; power off
00003e d24c      		rcall	switch_power_off
                 
                 	; reset input timeout
00003f e004      		ldi	temp1, CONTROL_TOT
000040 2eb0      		mov	control_timeout, temp1
                 		
                 ; 	rjmp	control_start		; for simulator only
                 
000041 e0f0      		ldi	ZH,high(version*2)
000042 e1ec      		ldi	ZL,low(version*2)
                 
                 ;**** UART Initialization ****
000043 e000      		ldi	temp1, 0
000044 bd00      		out	UBRRH, temp1
                 
000045 e100      		ldi	temp1, 16 ; 115200
000046 b909      		out	UBRRL, temp1
000047 e002      		ldi	temp1, 0x02	; #BK# set U2X
000048 b90b      		out	UCSRA, temp1
                 
                 ;		ldi	temp1, 34 ; 57600
                 ;		out	UBRRL, temp1
                 ;		ldi	temp1, 0x02	; #BK# set U2X
                 ;		out	UCSRA, temp1
                 
000049 e100      		ldi	temp1, 0x10 ; #HH# enable rx only!
00004a b90a      		out	UCSRB, temp1	; 
00004b b10c      		in 	temp1, UDR	; clear possibly pending rxc
00004c e000      		ldi	temp1, 0
00004d 2e50      		mov	uart_cnt, temp1
                 
                 ;   #HH# sending of version-string is commented out
                 ;		lpm
                 ;		adiw	ZL,1		;increment Z-pointer
                 ;		mov	temp1, r0	; (1)
                 ;		rcall	send_byte
                 
00004e d0cd      		rcall	wait260ms	; wait a while
00004f d0cc      		rcall	wait260ms
                 
000050 d09f      		rcall	beep_f1
000051 d0be      		rcall	wait30ms
000052 d0a0      		rcall	beep_f2
000053 d0bc      		rcall	wait30ms
000054 d0a1      		rcall	beep_f3
000055 d0ba      		rcall	wait30ms
000056 d0b9      		rcall	wait30ms
000057 d0b8      		rcall	wait30ms
000058 d0b7      		rcall	wait30ms
                 
                 ;   #HH# sending of version-string is commented out
                 ;		ldi	temp2, reset-version-1
                 ;v_str_rest:	lpm
                 ;		adiw	ZL,1		;increment Z-pointer
                 ;		mov	temp1, r0	; (6)
                 ;		rcall	send_byte
                 ;		dec	temp2
                 ;		brne	v_str_rest
                 
000059 b10c      		in	temp1, UDR  ; clear serial input - if existing
00005a b10c      		in	temp1, UDR
00005b 9a5f      		sbi	UCSRA, RXC		; clear flag
00005c 9a57      		sbi	UCSRB, RXCIE		; enable reception irq
                 
00005d d09b      		rcall	beep_f4			; signal: rcpuls ready
00005e d09a      		rcall	beep_f4
00005f d099      		rcall	beep_f4
                 
                 
                 control_start:	; init variables
000060 e001      		ldi	temp1, CHANGE_TIMEOUT
000061 2e30      		mov	tcnt0_change_tot, temp1
000062 ef02      		ldi	temp1, NO_POWER
000063 2e20      		mov	tcnt0_power_on, temp1
                 
000064 e000      		ldi	temp1, 0		; reset error counters
000065 2ec0      		mov	current_err,temp1
000066 2ed0      		mov	sys_control, temp1
                 
                 	; init registers and interrupts
000067 e105      		ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000068 bf08      		out	TIFR, temp1		; clear TOIE1,OCIE1A & TOIE0
000069 bf09      		out	TIMSK, temp1		; enable TOIE1,OCIE1A & TOIE0 interrupts
                 
00006a 9478      		sei				; enable all interrupts
                 
00006b e10e      		ldi	temp1, 30
00006c 9300 007b 		sts	duty_offset, temp1
                 
00006e d13c      		rcall	set_all_timings
                 
00006f d0a0      		rcall	wait30ms
                 
000070 c232      		rjmp	init_startup
                 		
                 ;-----bko-----------------------------------------------------------------
                 ; output compare timer1 interrupt
000071 b61f      t1oca_int:	in	i_sreg, SREG
000072 7f7e      		cbr	flags0, (1<<OCT1_PENDING) ; signal OCT1 passed
000073 be1f      		out	SREG, i_sreg
000074 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; overflow timer1 / happens all 32768µs
000075 b61f      t1ovfl_int:	in	i_sreg, SREG
000076 6870      		sbr	flags0, (1<<T1OVFL_FLAG)
                 
000077 20ee      		tst	t1_timeout
000078 f009      		breq	t1ovfl_10
000079 94ea      		dec	t1_timeout
                 
00007a 20bb      t1ovfl_10:	tst	control_timeout
00007b f411      		brne	t1ovfl_20
00007c 27ff      		clr	ZH
00007d c001      		rjmp	t1ovfl_99
00007e 94ba      t1ovfl_20:	dec	control_timeout
                 
                 
00007f be1f      t1ovfl_99:	out	SREG, i_sreg
000080 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; timer0 overflow interrupt
000081 b61f      t0ovfl_int:	in	i_sreg, SREG
000082 fd76      		sbrc	flags0, I_OFF_CYCLE
000083 c028      		rjmp	t0_on_cycle
                 
000084 6190      t0_off_cycle:	sbr	flags2, (1<<COMP_SAVE)
000085 9945      		sbic	ACSR, ACO		; mirror inverted ACO to bit-var
000086 7e9f      		cbr	flags2, (1<<COMP_SAVE)
                 
                 		; fastest possible ; #HH# ; DANGEROUS!!!
000087 2d46      		mov i_temp1, tcnt0_pwron_next
000088 c010      		rjmp set_next_pwm
                 
                 	; changes in PWM ?
000089 2d42      		mov	i_temp1, tcnt0_power_on
00008a 2d56      		mov	i_temp2, tcnt0_pwron_next
00008b 1754      		cp	i_temp2, i_temp1
00008c f430      		brsh	lower_pwm		; next power-on-time is lower or same
00008d 943a      higher_pwm:	dec	tcnt0_change_tot	; change-timeout passed ?
00008e f459      		brne	nFET_off		; .. no
00008f e051      		ldi	i_temp2, CHANGE_TIMEOUT	; .. yes - change-timeout for more power
000090 2e35      		mov	tcnt0_change_tot, i_temp2 ; reset change-timeout and decrement
000091 954a      		dec	i_temp1			; <dec> increases power-on-time
                 	
000092 c006      		rjmp	set_next_pwm
                 
000093 f031      lower_pwm:	breq	nFET_off		; pwm is unchanged
000094 943a      		dec	tcnt0_change_tot	; change-timeout passed ?
000095 f421      		brne	nFET_off		; .. no
000096 e051      		ldi	i_temp2, CHANGE_TOT_LOW ; .. yes - change-timeout for lower power
000097 2e35      		mov	tcnt0_change_tot, i_temp2 ; reset change-timeout and increment
000098 9543      		inc	i_temp1			; <inc> decreases power-on-time
                 		
000099 2e24      set_next_pwm:	mov	tcnt0_power_on, i_temp1
                 
00009a 6470      nFET_off:	sbr	flags0, (1<<I_OFF_CYCLE) ; PWM state = off cycle
                 
                 	; switch appropriate nFET off
00009b ff74      		sbrs	flags0, C_FET
00009c c003      		rjmp	test_AnFET
                 
                 ; C_FET is active
00009d ff81      		sbrs	flags1, FULL_POWER
00009e 9893      		CnFET_off		; Cn off
00009f c007      		rjmp	reload_t0_off_cycle
                 
0000a0 ff75      test_AnFET:	sbrs	flags0, A_FET
0000a1 c003      		rjmp	switch_BnFET
                 
                 ; A_FET is active
0000a2 ff81      switch_AnFET:	sbrs	flags1, FULL_POWER
0000a3 98a8      		AnFET_off		; An off
0000a4 c002      		rjmp	reload_t0_off_cycle
                 
                 ; B_FET is active
0000a5 ff81      switch_BnFET:	sbrs	flags1, FULL_POWER
0000a6 9891      		BnFET_off		; Bn off
                 
                 	; reload timer0 with the appropriate value
                 reload_t0_off_cycle:
0000a7 2d42      		mov	i_temp1, tcnt0_power_on
0000a8 5843      		subi	i_temp1, -POWER_RANGE	; adi i_temp1, POWER_RANGE
0000a9 9540      		com	i_temp1			; timer0 increments
0000aa bf42      		out	TCNT0, i_temp1
                 
0000ab c01b      		rjmp	t0_int_exit
                 
                 ; reload timer90 + switch appropriate nFET on
0000ac 2d42      t0_on_cycle:	mov	i_temp1, tcnt0_power_on
0000ad bf42      		out	TCNT0, i_temp1		; reload t0
0000ae 7b7f      		cbr	flags0, (1<<I_OFF_CYCLE) ; PWM state = on cycle (no off cycle)
                 
                 ; switch appropriate nFET on
0000af ff74      nFET_on:	sbrs	flags0, C_FET		; is Cn choppered ?
0000b0 c003      		rjmp	test_AnFET_on			; .. no - test An
0000b1 ff80      		sbrs	flags1, POWER_OFF
0000b2 9a93      		CnFET_on		; Cn on
0000b3 c007      		rjmp	eval_power_state
0000b4 ff75      test_AnFET_on:	sbrs	flags0, A_FET		; is An choppered ?
0000b5 c003      		rjmp	sw_BnFET_on			; .. no - Bn has to be choppered
0000b6 ff80      		sbrs	flags1, POWER_OFF
0000b7 9aa8      		AnFET_on		; An on
0000b8 c002      		rjmp	eval_power_state
0000b9 ff80      sw_BnFET_on:	sbrs	flags1, POWER_OFF
0000ba 9a91      		BnFET_on		; Bn on
                 
                 	; evaluate power state
                 eval_power_state:
0000bb 3844      		cpi	i_temp1, MAX_POWER+1
0000bc f418      		brsh	not_full_power
                 	; FULL POWER
0000bd 6082      		sbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = MAX_POWER means FULL_POWER
0000be 7f8e      		cbr	flags1, (1<<POWER_OFF)
0000bf c007      		rjmp	t0_int_exit
0000c0 3f42      not_full_power:	cpi	i_temp1, NO_POWER
0000c1 f018      		brlo	neither_full_nor_off
                 	; POWER OFF
0000c2 7f8d      		cbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = NO_POWER means power off
0000c3 6081      		sbr	flags1, (1<<POWER_OFF)
0000c4 c002      		rjmp	t0_int_exit
                 neither_full_nor_off:
0000c5 7f8d      		cbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = MAX_POWER means FULL_POWER
0000c6 7f8e      		cbr	flags1, (1<<POWER_OFF)
                 
0000c7 fd93      t0_int_exit:	sbrc	flags2, POFF_CYCLE
0000c8 6081      		sbr	flags1, (1<<POWER_OFF)
0000c9 be1f      		out	SREG, i_sreg
0000ca 9518      		reti
                 ;-----bko-----------------------------------------------------------------
0000cb b61f      urxc:		in	i_sreg, SREG
0000cc b14c      		in	i_temp1, UDR
                 
0000cd 3f45      		cpi	i_temp1, 0xf5
0000ce f0a1      		breq	x3d_sync
0000cf f480      		brcc	unknown_cmd
                 
0000d0 fd97      		sbrc	flags2, NO_SYNC
0000d1 c014      		rjmp	urxc_exit		; trough away
0000d2 2d59      		mov i_temp2, motor_count
0000d3 f091      		breq urxc_exit
0000d4 949a      		dec	motor_count
0000d5 f481      		brne	urxc_exit
                 
                 ; 10kHz do nothing range is 0-200
                 ;		mov	ZH, i_temp1
                 
                 ; 16kHz range is 0-125 - divide by 2 and add a quarter
0000d6 9546      		lsr	i_temp1				; 0-200 ==> 0-100
0000d7 2f54      		mov	i_temp2, i_temp1
0000d8 9556      		lsr	i_temp2
0000d9 9556      		lsr	i_temp2
0000da 0f45      		add	i_temp1, i_temp2
0000db 2ff4      		mov	ZH, i_temp1
                 
                 ; 20kHz range is 0-100 - divide by 2
                 ;		lsr	i_temp1				; 0-200 ==> 0-100
                 ;		mov	ZH, i_temp1
                 
0000dc 6890      		sbr	flags2, (1<<NO_SYNC)
0000dd e044      		ldi	i_temp1, CONTROL_TOT
0000de 2eb4      		mov	control_timeout, i_temp1
0000df c006      		rjmp	urxc_exit
                 
0000e0 9340 007e unknown_cmd:	sts	uart_command, i_temp1
0000e2 c003      		rjmp	urxc_exit
                 
0000e3 779f      x3d_sync:	cbr	flags2, (1<<NO_SYNC)
0000e4 e05c      		ldi	i_temp2, MOTOR_NUMBER
0000e5 2e95      		mov	motor_count, i_temp2
                 
0000e6 be1f      urxc_exit:	out	SREG, i_sreg
0000e7 9518      		reti
                 
0000e8 b61f      utxc:		in	i_sreg, SREG
0000e9 914d      		ld	i_temp1,X+
0000ea b94c      		out	UDR, i_temp1
0000eb 945a      		dec	uart_cnt
0000ec f409      		brne	utxc_90
0000ed 9856      		cbi	UCSRB, TXCIE		; disable irq
0000ee be1f      utxc_90:	out	SREG, i_sreg
0000ef 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; beeper: timer0 is set to 1µs/count
0000f0 ec38      beep_f1:	ldi	temp4, 200
0000f1 e510      		ldi	temp2, 80
0000f2 c009      		rjmp	beep
                 
0000f3 eb34      beep_f2:	ldi	temp4, 180
0000f4 e614      		ldi	temp2, 100
0000f5 c006      		rjmp	beep
                 
0000f6 ea30      beep_f3:	ldi	temp4, 160
0000f7 e718      		ldi	temp2, 120
0000f8 c003      		rjmp	beep
                 
0000f9 e634      beep_f4:	ldi	temp4, 100
0000fa ec18      		ldi	temp2, 200
0000fb c000      		rjmp	beep
                 
0000fc 2700      beep:		clr	temp1
0000fd bf02      		out	TCNT0, temp1
0000fe 9a97      		BpFET_on		; BpFET on
0000ff 9aa8      		AnFET_on		; CnFET on
000100 b702      beep_BpCn10:	in	temp1, TCNT0
000101 3400      		cpi	temp1, 64		; 32µs on
000102 f7e9      		brne	beep_BpCn10
000103 9897      		BpFET_off		; BpFET off
000104 98a8      		AnFET_off		; CnFET off
000105 e120      		ldi	temp3, 16		; 2040µs off
000106 2700      beep_BpCn12:	clr	temp1
000107 bf02      		out	TCNT0, temp1
000108 b702      beep_BpCn13:	in	temp1, TCNT0
000109 1703      		cp	temp1, temp4
00010a f7e9      		brne	beep_BpCn13
00010b 952a      		dec	temp3
00010c f7c9      		brne	beep_BpCn12
00010d 951a      		dec	temp2
00010e f769      		brne	beep
00010f 9508      		ret
                 
000110 e11e      wait30ms:	ldi	temp2, 30
000111 e120      beep_BpCn20:	ldi	temp3, 16
000112 2700      beep_BpCn21:	clr	temp1
000113 bf02      		out	TCNT0, temp1
000114 b702      beep_BpCn22:	in	temp1, TCNT0
000115 3f0f      		cpi	temp1, 255
000116 f7e9      		brne	beep_BpCn22
000117 952a      		dec	temp3
000118 f7c9      		brne	beep_BpCn21
000119 951a      		dec	temp2
00011a f7b1      		brne	beep_BpCn20
00011b 9508      		ret
                 
                 	; 256 periods = 261ms silence
00011c e010      wait260ms:	ldi	temp2, 0	; = 256
00011d e120      beep2_BpCn20:	ldi	temp3, 16
00011e 2700      beep2_BpCn21:	clr	temp1
00011f bf02      		out	TCNT0, temp1
000120 b702      beep2_BpCn22:	in	temp1, TCNT0
000121 3f0f      		cpi	temp1, 255
000122 f7e9      		brne	beep2_BpCn22
000123 952a      		dec	temp3
000124 f7c9      		brne	beep2_BpCn21
000125 951a      		dec	temp2
000126 f7b1      		brne	beep2_BpCn20
000127 9508      		ret
                 ;-----bko-----------------------------------------------------------------
000128 e030      tcnt1_to_temp:	ldi	temp4, T1STOP		; stop timer1
000129 bd3e      		out	TCCR1B, temp4
00012a e032      		ldi	temp4, T1CK8		; preload temp with restart timer1
00012b b50c      		in	temp1, TCNT1L		;  - the preload cycle is needed to complete stop operation
00012c b51d      		in	temp2, TCNT1H
00012d bd3e      		out	TCCR1B, temp4
00012e 9508      		ret				; !!! ext0int stays disabled - must be enabled again by caller
                 	; there seems to be only one TEMP register in the AVR
                 	; if the ext0int interrupt falls between readad LOW value while HIGH value is captured in TEMP and
                 	; read HIGH value, TEMP register is changed in ext0int routine
                 ;-----bko-----------------------------------------------------------------
                 evaluate_sys_state:
00012f 7e8f      		cbr	flags1, (1<<EVAL_SYS_STATE)
000130 ff77      		sbrs	flags0, T1OVFL_FLAG
000131 c014      		rjmp	eval_sys_s99
                 
                 	; do it not more often as every 32µs
000132 777f      		cbr	flags0, (1<<T1OVFL_FLAG)
                 
000133 c012      		rjmp	eval_sys_s99		; disabled ;-)
                 
                 	; control current
000134 c005      eval_sys_i:	rjmp	eval_sys_i_ok
                 
000135 2d0c      		mov	temp1, current_err
000136 3003      		cpi	temp1, CURRENT_ERR_MAX
000137 f478      		brcc	panic_exit
000138 94c3      		inc	current_err
000139 c003      		rjmp	eval_sys_ub
                 
00013a 20cc      eval_sys_i_ok:	tst	current_err
00013b f009      		breq	eval_sys_ub
00013c 94ca      		dec	current_err
                 
                 	; control voltage
00013d c005      eval_sys_ub:	rjmp	eval_sys_ub_ok
                 
00013e 2d0d      		mov	temp1, sys_control
00013f 370d      		cpi	temp1, POWER_RANGE
000140 f428      		brcc	eval_sys_s99
000141 94d3      		inc	sys_control
000142 c003      		rjmp	eval_sys_s99
                 
000143 20dd      eval_sys_ub_ok:	tst	sys_control
000144 f009      		breq	eval_sys_s99
000145 94da      		dec	sys_control
                 		
000146 9508      eval_sys_s99:	ret
                 
                 panic_exit:	; !!!!!! OVERCURRENT !!!!!!!!
000147 94f8      		cli
000148 ced4      		rjmp	reset
                 ;-----bko-----------------------------------------------------------------
000149 2f0f      set_new_duty:	mov	temp1, ZH
00014a 190d      		sub	temp1, sys_control
00014b f408      		brcc	set_new_duty10
00014c e00d      		ldi	temp1, MIN_DUTY-1
                 	; evaluate RPM range
00014d 9110 0066 set_new_duty10:	lds	temp2, timing_x
00014f 2311      		tst	temp2
000150 f421      		brne	set_new_duty12
000151 9110 0065 		lds	temp2, timing_h	; get actual RPM reference high
000153 3c10      		cpi	temp2, PWR_RANGE1	; lower range1 ?
000154 f038      		brcs	set_new_duty20		; on carry - test next range
                 	; lower as range1
000155 6091      set_new_duty12:	sbr	flags2, (1<<RPM_RANGE1)
000156 6092      		sbr	flags2, (1<<RPM_RANGE2)
000157 e11f      		ldi	temp2, PWR_MAX_RPM1	; higher than range1 power max ?
000158 1701      		cp	temp1, temp2
000159 f060      		brcs	set_new_duty40		; on carry - not higher, no restriction
00015a 2f01      		mov	temp1, temp2		; low (range1) RPM - set PWR_MAX_RPM1
00015b c00a      		rjmp	set_new_duty40
                 	; higher as range1
00015c 3810      set_new_duty20:	cpi	temp2, PWR_RANGE2	; lower range2 ?
00015d f038      		brcs	set_new_duty30		; on carry - not lower, no restriction
00015e 7f9e      set_new_duty22:	cbr	flags2, (1<<RPM_RANGE1)
00015f 6092      		sbr	flags2, (1<<RPM_RANGE2)
000160 e31e      		ldi	temp2, PWR_MAX_RPM2	; higher than range2 power max ?
000161 1701      		cp	temp1, temp2
000162 f018      		brcs	set_new_duty40		; on carry - not higher, no restriction
000163 2f01      		mov	temp1, temp2		; low (range2) RPM - set PWR_MAX_RPM2
000164 c001      		rjmp	set_new_duty40
                 	; higher as range2
000165 7f9c      set_new_duty30:	cbr	flags2, (1<<RPM_RANGE1)+(1<<RPM_RANGE2)
                 	; range limits are evaluated - look for STARTUP conditions
000166 ff95      set_new_duty40:	sbrs	flags2, STARTUP
000167 c009      		rjmp	set_new_duty50
000168 e124      		ldi	temp3, PWR_STARTUP	; at least PWR_STARTUP ?
000169 1702      		cp	temp1, temp3
00016a f410      		brcc	set_new_duty42		; on no carry - higher than PWR_STARTUP, test PWR_MAX_STARTUP
00016b e104      		ldi	temp1, PWR_STARTUP	; lower - set to PWR_STARTUP
00016c c004      		rjmp	set_new_duty50
00016d e221      set_new_duty42:	ldi	temp3, PWR_MAX_STARTUP	; limit power in startup phase
00016e 1702      		cp	temp1, temp3
00016f f008      		brcs	set_new_duty50		; on carry - not higher, test range 2
000170 2f02      		mov	temp1, temp3		; set PWR_MAX_STARTUP limit
                 
000171 9500      set_new_duty50:	com	temp1			; down-count to up-count (T0)
000172 2e60      		mov	tcnt0_pwron_next, temp1	; save in next
                 	; tcnt0_power_on is updated to tcnt0_pwron_next in acceptable steps
000173 9508      		ret
                 ;-----bko-----------------------------------------------------------------
000174 7d8f      evaluate_rpm:	cbr	flags1, (1<<EVAL_RPM)
000175 9120 006c 		lds	temp3, rpm_x
000177 9110 006b 		lds	temp2, rpm_h
                 
000179 9100 006a 		lds	temp1, rpm_l	; subtract 1/256
00017b 1b01      		sub	temp1, temp2
00017c 9300 006a 		sts	rpm_l, temp1
00017e 9100 006b 		lds	temp1, rpm_h
000180 0b02      		sbc	temp1, temp3
000181 9300 006b 		sts	rpm_h, temp1
000183 9100 006c 		lds	temp1, rpm_x
000185 4000      		sbci	temp1, 0
000186 9300 006c 		sts	rpm_x, temp1
                 
000188 9120 0069 		lds	temp3, timing_acc_x
00018a 9110 0068 		lds	temp2, timing_acc_h
00018c 9100 0067 		lds	temp1, timing_acc_l
00018e 9526      		lsr	temp3		; make one complete commutation cycle
00018f 9517      		ror	temp2
000190 9507      		ror	temp1
000191 9526      		lsr	temp3
000192 9517      		ror	temp2
000193 9507      		ror	temp1
                 	; temp3 is zero now - for sure !!
000194 9320 0069 		sts	timing_acc_x, temp3
000196 9320 0068 		sts	timing_acc_h, temp3
000198 9320 0067 		sts	timing_acc_l, temp3
                 	; and add the result as 1/256
00019a 9120 006a 		lds	temp3, rpm_l
00019c 0f20      		add	temp3, temp1
00019d 9320 006a 		sts	rpm_l, temp3
00019f 9120 006b 		lds	temp3, rpm_h
0001a1 1f21      		adc	temp3, temp2
0001a2 9320 006b 		sts	rpm_h, temp3
0001a4 e000      		ldi	temp1, 0
0001a5 9120 006c 		lds	temp3, rpm_x
0001a7 1f20      		adc	temp3, temp1
0001a8 9320 006c 		sts	rpm_x, temp3
                 
0001aa 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 set_all_timings:
0001ab eec8      		ldi	YL, low  (timeoutSTART)
0001ac efdd      		ldi	YH, high (timeoutSTART)
0001ad 93c0 0071 		sts	wt_OCT1_tot_l, YL
0001af 93d0 0072 		sts	wt_OCT1_tot_h, YH
0001b1 ef2f      		ldi	temp3, 0xff
0001b2 e13f      		ldi	temp4, 0x1f
0001b3 9320 006d 		sts	wt_comp_scan_l, temp3
0001b5 9330 006e 		sts	wt_comp_scan_h, temp4
0001b7 9320 006f 		sts	com_timing_l, temp3
0001b9 9330 0070 		sts	com_timing_h, temp4
                 
0001bb e0e3      set_timing_v:	ldi	ZL, 0x03
0001bc 93e0 0066 		sts	timing_x, ZL
0001be ef3f      		ldi	temp4, 0xff
0001bf 9330 0065 		sts	timing_h, temp4
0001c1 ef2f      		ldi	temp3, 0xff
0001c2 9320 0064 		sts	timing_l, temp3
                 
0001c4 9508      		ret
                 ;-----bko-----------------------------------------------------------------
0001c5 df62      update_timing:	rcall	tcnt1_to_temp
0001c6 9300 0060 		sts	tcnt1_sav_l, temp1
0001c8 9310 0061 		sts	tcnt1_sav_h, temp2
0001ca 0f0c      		add	temp1, YL
0001cb 1f1d      		adc	temp2, YH
0001cc e035      		ldi	temp4, (1<<TOIE1)+(1<<TOIE0)
0001cd bf39      		out	TIMSK, temp4
0001ce bd1b      		out	OCR1AH, temp2
0001cf bd0a      		out	OCR1AL, temp1
0001d0 6071      		sbr	flags0, (1<<OCT1_PENDING)
0001d1 e135      		ldi	temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; enable interrupt again
0001d2 bf39      		out	TIMSK, temp4
                 
                 	; calculate next waiting times - timing(-l-h-x) holds the time of 4 commutations
0001d3 9100 0064 		lds	temp1, timing_l
0001d5 9110 0065 		lds	temp2, timing_h
0001d7 91e0 0066 		lds	ZL, timing_x
                 
0001d9 9300 0073 		sts	zero_wt_l, temp1	; save for zero crossing timeout
0001db 9310 0074 		sts	zero_wt_h, temp2
0001dd 23ee      		tst	ZL
0001de f029      		breq	update_t00
0001df ef3f      		ldi	temp4, 0xff
0001e0 9330 0073 		sts	zero_wt_l, temp4	; save for zero crossing timeout
0001e2 9330 0074 		sts	zero_wt_h, temp4
                 update_t00:
0001e4 95e6      		lsr	ZL			; build a quarter
0001e5 9517      		ror	temp2
0001e6 9507      		ror	temp1
                 
0001e7 95e6      		lsr	ZL
0001e8 9517      		ror	temp2
0001e9 9507      		ror	temp1
0001ea 9120 0064 		lds	temp3, timing_l		; .. and subtract from timing
0001ec 9130 0065 		lds	temp4, timing_h
0001ee 91e0 0066 		lds	ZL, timing_x
0001f0 1b20      		sub	temp3, temp1
0001f1 0b31      		sbc	temp4, temp2
0001f2 40e0      		sbci	ZL, 0
                 
0001f3 9100 0060 		lds	temp1, tcnt1_sav_l	; calculate this commutation time
0001f5 9110 0061 		lds	temp2, tcnt1_sav_h
0001f7 91c0 0062 		lds	YL, last_tcnt1_l
0001f9 91d0 0063 		lds	YH, last_tcnt1_h
0001fb 9300 0062 		sts	last_tcnt1_l, temp1
0001fd 9310 0063 		sts	last_tcnt1_h, temp2
0001ff 1b0c      		sub	temp1, YL
000200 0b1d      		sbc	temp2, YH
000201 9300 0075 		sts	last_com_l, temp1
000203 9310 0076 		sts	last_com_h, temp2
                 
000205 0f20      		add	temp3, temp1		; .. and add to timing
000206 1f31      		adc	temp4, temp2
000207 e010      		ldi	temp2, 0
000208 1fe1      		adc	ZL, temp2
                 
                 	; limit RPM to 120.000
000209 23ee      		tst	ZL
00020a f461      		brne	update_t90
00020b 2333      		tst	temp4
00020c f021      		breq	update_t10
00020d 3032      		cpi	temp4, 0x02
00020e f441      		brne	update_t90
00020f 3928      		cpi	temp3, 0x98		; 0x298 = 120.000 RPM
000210 f430      		brcc	update_t90
                 	; set RPM to 120.000
000211 e032      update_t10:	ldi	temp4, 0x02
000212 e928      		ldi	temp3, 0x98
000213 20ff      		tst	run_control 
000214 f411      		brne	update_t90		; just active
000215 ef0f      		ldi	temp1, 0xff		; not active - reactivate
000216 2ef0      		mov	run_control, temp1
                 
000217 9320 0064 update_t90:	sts	timing_l, temp3
000219 9330 0065 		sts	timing_h, temp4
00021b 93e0 0066 		sts	timing_x, ZL
00021d 30e4      		cpi	ZL, 4		; limit range to 0x3ffff
00021e f008      		brcs	update_t99
00021f df9b      		rcall	set_timing_v
                 
000220 9100 0067 update_t99:	lds	temp1, timing_acc_l
000222 0f02      		add	temp1, temp3
000223 9300 0067 		sts	timing_acc_l, temp1
000225 9100 0068 		lds	temp1, timing_acc_h
000227 1f03      		adc	temp1, temp4
000228 9300 0068 		sts	timing_acc_h, temp1
00022a 9100 0069 		lds	temp1, timing_acc_x
00022c 1f0e      		adc	temp1, ZL
00022d 9300 0069 		sts	timing_acc_x, temp1
                 
00022f 95e6      		lsr	ZL			; a 16th is the next wait before scan
000230 9537      		ror	temp4
000231 9527      		ror	temp3
000232 95e6      		lsr	ZL
000233 9537      		ror	temp4
000234 9527      		ror	temp3
000235 95e6      		lsr	ZL
000236 9537      		ror	temp4
000237 9527      		ror	temp3
000238 95e6      		lsr	ZL
000239 9537      		ror	temp4
00023a 9527      		ror	temp3
00023b 9320 006d 		sts	wt_comp_scan_l, temp3
00023d 9330 006e 		sts	wt_comp_scan_h, temp4
                 
                 	; use the same value for commutation timing (15°)
00023f 9320 006f 		sts	com_timing_l, temp3
000241 9330 0070 		sts	com_timing_h, temp4
                 
000243 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 calc_next_timing:
000244 91c0 006d 		lds	YL, wt_comp_scan_l	; holds wait-before-scan value
000246 91d0 006e 		lds	YH, wt_comp_scan_h
000248 df7c      		rcall	update_timing
                 
000249 9508      		ret
                 
00024a fd70      wait_OCT1_tot:	sbrc	flags0, OCT1_PENDING
00024b cffe      		rjmp	wait_OCT1_tot
                 
00024c 9837      set_OCT1_tot:	cbi	ADCSRA, ADEN		; switch to comparator multiplexed
00024d b700      		in	temp1, SFIOR
00024e 6008      		ori	temp1, (1<<ACME)
00024f bf00      		out	SFIOR, temp1
                 
000250 91d0 0074 		lds	YH, zero_wt_h
000252 91c0 0073 		lds	YL, zero_wt_l
000254 ded3      		rcall	tcnt1_to_temp
000255 0f0c      		add	temp1, YL
000256 1f1d      		adc	temp2, YH
000257 e035      		ldi	temp4, (1<<TOIE1)+(1<<TOIE0)
000258 bf39      		out	TIMSK, temp4
000259 bd1b      		out	OCR1AH, temp2
00025a bd0a      		out	OCR1AL, temp1
00025b 6071      		sbr	flags0, (1<<OCT1_PENDING)
00025c e135      		ldi	temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00025d bf39      		out	TIMSK, temp4
                 
00025e 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 wait_OCT1_before_switch:
00025f dec8      		rcall	tcnt1_to_temp
000260 91c0 006f 		lds	YL, com_timing_l
000262 91d0 0070 		lds	YH, com_timing_h
000264 0f0c      		add	temp1, YL
000265 1f1d      		adc	temp2, YH
000266 e025      		ldi	temp3, (1<<TOIE1)+(1<<TOIE0)
000267 bf29      		out	TIMSK, temp3
000268 bd1b      		out	OCR1AH, temp2
000269 bd0a      		out	OCR1AL, temp1
00026a 6071      		sbr	flags0, (1<<OCT1_PENDING)
00026b e125      		ldi	temp3, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00026c bf29      		out	TIMSK, temp3
                 
                 	; don't waste time while waiting - do some controls, if indicated
                 
00026d fd84      		sbrc	flags1, EVAL_SYS_STATE
00026e dec0      		rcall	evaluate_sys_state
                 
00026f fd86      		sbrc	flags1, EVAL_PWM
000270 ded8      		rcall	set_new_duty
                 
000271 fd85      		sbrc	flags1, EVAL_RPM
000272 df01      		rcall	evaluate_rpm
                 
000273 fd70      OCT1_wait:	sbrc	flags0, OCT1_PENDING
000274 cffe      		rjmp	OCT1_wait
000275 9508      		ret
                 ;-----bko-----------------------------------------------------------------
000276 91c0 0071 start_timeout:	lds	YL, wt_OCT1_tot_l
000278 91d0 0072 		lds	YH, wt_OCT1_tot_h
00027a df4a      		rcall	update_timing
                 
00027b b50c      		in	temp1, TCNT1L
00027c 700f      		andi	temp1, 0x0f
00027d 1bd0      		sub	YH, temp1
00027e 3bdb      		cpi	YH, high (timeoutMIN)
00027f f408      		brcc	set_tot2
000280 efdd      		ldi	YH, high (timeoutSTART)		
                 set_tot2:
000281 93d0 0072 		sts	wt_OCT1_tot_h, YH
                 
000283 d019      		rcall	sync_with_poweron	; wait at least 100+ microseconds
000284 d018      		rcall	sync_with_poweron	; for demagnetisation - one sync may be added
                 
000285 9508      		ret
                 ;-----bko-----------------------------------------------------------------
000286 9a5e      send_byte:	sbi	UCSRA,TXC	; clear flag
000287 b90c      		out	UDR,temp1
000288 9b5e      send_b20:	sbis	UCSRA,TXC
000289 cffe      		rjmp	send_b20
00028a 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 switch_power_off:
00028b e0fd      		ldi	ZH, MIN_DUTY-1		; ZH is new_duty
00028c ef02      		ldi	temp1, NO_POWER		; lowest tcnt0_power_on value
00028d 2e20      		mov	tcnt0_power_on, temp1
00028e 2e60      		mov	tcnt0_pwron_next, temp1
00028f e000      		ldi	temp1, INIT_PC		; all off
000290 bb05      		out	PORTC, temp1
000291 e001      		ldi	temp1, INIT_PD
000292 bb02      		out	PORTD, temp1
000293 e001      		ldi	temp1, CHANGE_TIMEOUT	; reset change-timeout
000294 2e30      		mov	tcnt0_change_tot, temp1
000295 6081      		sbr	flags1, (1<<POWER_OFF)	; disable power on
000296 7f97      		cbr	flags2, (1<<POFF_CYCLE)
000297 6290      		sbr	flags2, (1<<STARTUP)
000298 9508      		ret				; motor is off
                 ;-----bko-----------------------------------------------------------------
000299 e008      wait_if_spike:	ldi	temp1, 8
00029a 950a      wait_if_spike2:	dec	temp1
00029b f7f1      		brne	wait_if_spike2
00029c 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 sync_with_poweron:
00029d fd76      		sbrc	flags0, I_OFF_CYCLE	; first wait for power on
00029e cffe      		rjmp	sync_with_poweron
                 wait_for_poweroff:
00029f ff76      		sbrs	flags0, I_OFF_CYCLE	; now wait for power off
0002a0 cffe      		rjmp	wait_for_poweroff
0002a1 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 motor_brake:
                 .if MOT_BRAKE == 1
                 .endif	; MOT_BRAKE == 1
0002a2 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 ; **** startup loop ****
0002a3 dfe7      init_startup:	rcall	switch_power_off
0002a4 dffd      		rcall	motor_brake
                 wait_for_power_on:
                 
0002a5 98c1          HHDEBUGLED_off
                 
                 .if	DEBUG_LEDS == 1
                 .endif
0002a6 30fe      		cpi	ZH, MIN_DUTY
0002a7 f3e8      		brcs	wait_for_power_on
                 
0002a8 e104      		ldi	temp1, PWR_STARTUP	; begin startup with low power
0002a9 9500      		com	temp1
0002aa 2e60      		mov	tcnt0_pwron_next, temp1
                 
0002ab 9837      		cbi	ADCSRA, ADEN		; switch to comparator multiplexed
0002ac b700      		in	temp1, SFIOR
0002ad 6008      		ori	temp1, (1<<ACME)
0002ae bf00      		out	SFIOR, temp1
                 
0002af e000      		ldi	temp1, INIT_PC		; all off
0002b0 bb05      		out	PORTC, temp1
0002b1 e001      		ldi	temp1, INIT_PD
0002b2 bb02      		out	PORTD, temp1
0002b3 e10b      		ldi	temp1, 27		; wait about 5mikosec
0002b4 950a      FETs_off_wt:	dec	temp1
0002b5 f7f1      		brne	FETs_off_wt
                 
0002b6 d13e      		rcall	com5com6
0002b7 d143      		rcall	com6com1
                 
0002b8 7f9b      		cbr	flags2, (1<<SCAN_TIMEOUT)
0002b9 e000      		ldi	temp1, 0
0002ba 9300 007c 		sts	goodies, temp1
                 
0002bc e500      		ldi	temp1, 80	; x 32msec
0002bd 2ee0      		mov	t1_timeout, temp1
                 
0002be deec      		rcall	set_all_timings
                 
0002bf dfb6      		rcall	start_timeout
                 
                 	; fall through start1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** start control loop ****
                 
                 ; state 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 start1:
                 .if	DEBUG_LEDS == 1
                 .endif
0002c0 ff94      		sbrs	flags2, COMP_SAVE	; high ?
0002c1 c00f      		rjmp	start1_2		; .. no - loop, while high
                 
0002c2 fd70      start1_0:	sbrc	flags0, OCT1_PENDING
0002c3 c002      		rjmp	start1_1
0002c4 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002c5 c012      		rjmp	start1_9
0002c6 dfd6      start1_1:	rcall	sync_with_poweron
                 
0002c7 fd94      		sbrc	flags2, COMP_SAVE	; high ?
0002c8 cff9      		rjmp	start1_0		; .. no - loop, while high
                 
                 ; do the special 120° switch
0002c9 e000      		ldi	temp1, 0
0002ca 9300 007c 		sts	goodies, temp1
0002cc d0fa      		rcall	com1com2
0002cd d0ff      		rcall	com2com3
0002ce d10f      		rcall	com3com4
0002cf dfa6      		rcall	start_timeout
0002d0 c030      		rjmp	start4
                 	
0002d1 fd70      start1_2:	sbrc	flags0, OCT1_PENDING
0002d2 c002      		rjmp	start1_3
0002d3 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002d4 c003      		rjmp	start1_9
0002d5 dfc7      start1_3:	rcall	sync_with_poweron
0002d6 ff94      		sbrs	flags2, COMP_SAVE	; high ?
0002d7 cff9      		rjmp	start1_2		; .. no - loop, while low
                 
                 start1_9:
0002d8 d0ee      		rcall	com1com2
0002d9 df9c      		rcall	start_timeout
                 
                 ; state 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
0002da fd94      start2:		sbrc	flags2, COMP_SAVE
0002db c008      		rjmp	start2_2
                 
0002dc fd70      start2_0:	sbrc	flags0, OCT1_PENDING
0002dd c002      		rjmp	start2_1
0002de 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002df c00b      		rjmp	start2_9
0002e0 dfbc      start2_1:	rcall	sync_with_poweron
0002e1 ff94      		sbrs	flags2, COMP_SAVE
0002e2 cff9      		rjmp	start2_0
0002e3 c007      		rjmp	start2_9
                 
0002e4 fd70      start2_2:	sbrc	flags0, OCT1_PENDING
0002e5 c002      		rjmp	start2_3
0002e6 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002e7 c003      		rjmp	start2_9
0002e8 dfb4      start2_3:	rcall	sync_with_poweron
0002e9 fd94      		sbrc	flags2, COMP_SAVE
0002ea cff9      		rjmp	start2_2
                 
                 start2_9:
0002eb d0e1      		rcall	com2com3
0002ec df89      		rcall	start_timeout
                 
                 ; state 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
0002ed ff94      start3:		sbrs	flags2, COMP_SAVE
0002ee c008      		rjmp	start3_2
                 
0002ef fd70      start3_0:	sbrc	flags0, OCT1_PENDING
0002f0 c002      		rjmp	start3_1
0002f1 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002f2 c00b      		rjmp	start3_9
0002f3 dfa9      start3_1:	rcall	sync_with_poweron
0002f4 fd94      		sbrc	flags2, COMP_SAVE
0002f5 cff9      		rjmp	start3_0
0002f6 c007      		rjmp	start3_9
                 
0002f7 fd70      start3_2:	sbrc	flags0, OCT1_PENDING
0002f8 c002      		rjmp	start3_3
0002f9 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002fa c003      		rjmp	start3_9
0002fb dfa1      start3_3:	rcall	sync_with_poweron
0002fc ff94      		sbrs	flags2, COMP_SAVE
0002fd cff9      		rjmp	start3_2
                 
                 start3_9:
0002fe d0df      		rcall	com3com4
0002ff de49      		rcall	set_new_duty
000300 df75      		rcall	start_timeout
                 
                 ; state 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
                 
                 start4:
                 .if	DEBUG_LEDS == 1
                 .endif
000301 fd94      		sbrc	flags2, COMP_SAVE
000302 c008      		rjmp	start4_2
                 
000303 fd70      start4_0:	sbrc	flags0, OCT1_PENDING
000304 c002      		rjmp	start4_1
000305 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000306 c00b      		rjmp	start4_9
000307 df95      start4_1:	rcall	sync_with_poweron
000308 ff94      		sbrs	flags2, COMP_SAVE
000309 cff9      		rjmp	start4_0
00030a c007      		rjmp	start4_9
                 
00030b fd70      start4_2:	sbrc	flags0, OCT1_PENDING
00030c c002      		rjmp	start4_3
00030d 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00030e c003      		rjmp	start4_9
00030f df8d      start4_3:	rcall	sync_with_poweron
000310 fd94      		sbrc	flags2, COMP_SAVE
000311 cff9      		rjmp	start4_2
                 
                 start4_9:
000312 d0d1      		rcall	com4com5
000313 df62      		rcall	start_timeout
                 
                 
                 ; state 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
                 
000314 ff94      start5:		sbrs	flags2, COMP_SAVE
000315 c008      		rjmp	start5_2
                 
000316 fd70      start5_0:	sbrc	flags0, OCT1_PENDING
000317 c002      		rjmp	start5_1
000318 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000319 c00b      		rjmp	start5_9
00031a df82      start5_1:	rcall	sync_with_poweron
00031b fd94      		sbrc	flags2, COMP_SAVE
00031c cff9      		rjmp	start5_0
00031d c007      		rjmp	start5_9
                 
00031e fd70      start5_2:	sbrc	flags0, OCT1_PENDING
00031f c002      		rjmp	start5_3
000320 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000321 c003      		rjmp	start5_9
000322 df7a      start5_3:	rcall	sync_with_poweron
000323 ff94      		sbrs	flags2, COMP_SAVE
000324 cff9      		rjmp	start5_2
                 
                 start5_9:
000325 d0cf      		rcall	com5com6
000326 de08      		rcall	evaluate_sys_state
000327 df4e      		rcall	start_timeout
                 
                 ; state 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
                 start6:
                 .if	DEBUG_LEDS == 1
                 .endif
000328 fd94      		sbrc	flags2, COMP_SAVE
000329 c008      		rjmp	start6_2
                 
00032a fd70      start6_0:	sbrc	flags0, OCT1_PENDING
00032b c002      		rjmp	start6_1
00032c 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00032d c00b      		rjmp	start6_9
00032e df6e      start6_1:	rcall	sync_with_poweron
00032f ff94      		sbrs	flags2, COMP_SAVE
000330 cff9      		rjmp	start6_0
000331 c007      		rjmp	start6_9
                 
000332 fd70      start6_2:	sbrc	flags0, OCT1_PENDING
000333 c002      		rjmp	start6_3
000334 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000335 c003      		rjmp	start6_9
000336 df66      start6_3:	rcall	sync_with_poweron
000337 fd94      		sbrc	flags2, COMP_SAVE
000338 cff9      		rjmp	start6_2
                 
                 start6_9:
000339 d0c1      		rcall	com6com1
                 
00033a 2d02      		mov	temp1, tcnt0_power_on
00033b 3f02      		cpi	temp1, NO_POWER
00033c f409      		brne	s6_power_ok
00033d cf65      		rjmp	init_startup
                 
00033e 20bb      s6_power_ok:	tst	control_timeout
00033f f409      		brne	s6_rcp_ok
000340 c072      		rjmp	restart_control
                 
000341 20ee      s6_rcp_ok:	tst	t1_timeout
000342 f409      		brne	s6_test_rpm
000343 cf5f      		rjmp	init_startup		;-) demich
                 		
000344 9100 0066 s6_test_rpm:	lds	temp1, timing_x
000346 2300      		tst	temp1
000347 f421      		brne	s6_goodies
000348 9100 0065 		lds	temp1, timing_h		; get actual RPM reference high
                 ;		cpi	temp1, PWR_RANGE1
00034a 3800      		cpi	temp1, PWR_RANGE2
00034b f050      		brcs	s6_run1
                 
00034c 9100 007c s6_goodies:	lds	temp1, goodies
00034e fd92      		sbrc	flags2, SCAN_TIMEOUT
00034f 2700      		clr	temp1
000350 9503      		inc	temp1
000351 9300 007c 		sts	goodies,  temp1
000353 7f9b      		cbr	flags2, (1<<SCAN_TIMEOUT)
000354 330c      		cpi	temp1, ENOUGH_GOODIES
000355 f030      		brcs	s6_start1	
                 
000356 ef0f      s6_run1:	ldi	temp1, 0xff
000357 2ef0      		mov	run_control, temp1
                 
000358 deeb      		rcall	calc_next_timing
000359 def2      		rcall	set_OCT1_tot
                 
00035a 7d9f      		cbr	flags2, (1<<STARTUP)
00035b c002      		rjmp	run1			; running state begins
                 
00035c df19      s6_start1:	rcall	start_timeout		; need to be here for a correct temp1=comp_state
00035d cf62      		rjmp	start1			; go back to state 1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** running control loop ****
                 
                 ; run 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 
                 run1:
                 .if	DEBUG_LEDS == 1
                 .endif
00035e d058       		rcall	wait_for_low
00035f ff70      		sbrs	flags0, OCT1_PENDING
000360 c043      		rjmp	run_to_start
000361 d05d      		rcall	wait_for_high
000362 ff70      		sbrs	flags0, OCT1_PENDING
000363 c040      		rjmp	run_to_start
000364 6280      		sbr	flags1, (1<<EVAL_RPM)
000365 def9      		rcall	wait_OCT1_before_switch
000366 d060      		rcall	com1com2
000367 dedc      		rcall	calc_next_timing
000368 dee1      		rcall	wait_OCT1_tot
                 		
                 ; run 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
000369 d055      run2:		rcall	wait_for_high
00036a ff70      		sbrs	flags0, OCT1_PENDING
00036b c038      		rjmp	run_to_start
00036c d04a      		rcall	wait_for_low
00036d ff70      		sbrs	flags0, OCT1_PENDING
00036e c035      		rjmp	run_to_start
00036f deef      		rcall	wait_OCT1_before_switch
000370 d05c      		rcall	com2com3
000371 ded2      		rcall	calc_next_timing
000372 ded7      		rcall	wait_OCT1_tot
                 
                 ; run 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
000373 d043      run3:		rcall	wait_for_low
000374 ff70      		sbrs	flags0, OCT1_PENDING
000375 c02e      		rjmp	run_to_start
000376 d048      		rcall	wait_for_high
000377 ff70      		sbrs	flags0, OCT1_PENDING
000378 c02b      		rjmp	run_to_start
000379 6480      		sbr	flags1, (1<<EVAL_PWM)
00037a dee4      		rcall	wait_OCT1_before_switch
00037b d062      		rcall	com3com4
00037c dec7      		rcall	calc_next_timing
00037d decc      		rcall	wait_OCT1_tot
                 
                 ; run 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
                 run4:
                 .if	DEBUG_LEDS == 1
                 .endif
00037e d040      		rcall	wait_for_high
00037f ff70      		sbrs	flags0, OCT1_PENDING
000380 c023      		rjmp	run_to_start
000381 d035      		rcall	wait_for_low
000382 ff70      		sbrs	flags0, OCT1_PENDING
000383 c020      		rjmp	run_to_start
000384 deda      		rcall	wait_OCT1_before_switch
000385 d05e      		rcall	com4com5
000386 debd      		rcall	calc_next_timing
000387 dec2      		rcall	wait_OCT1_tot
                 
                 ; run 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
000388 d02e      run5:		rcall	wait_for_low
000389 ff70      		sbrs	flags0, OCT1_PENDING
00038a c019      		rjmp	run_to_start
00038b d033      		rcall	wait_for_high
00038c ff70      		sbrs	flags0, OCT1_PENDING
00038d c016      		rjmp	run_to_start
00038e 6180      		sbr	flags1, (1<<EVAL_SYS_STATE)
00038f decf      		rcall	wait_OCT1_before_switch
000390 d064      		rcall	com5com6
000391 deb2      		rcall	calc_next_timing
000392 deb7      		rcall	wait_OCT1_tot
                 
                 ; run 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
                 run6:
                 .if	DEBUG_LEDS == 1
                 .endif
000393 d02b      		rcall	wait_for_high
000394 ff70      		sbrs	flags0, OCT1_PENDING
000395 c00e      		rjmp	run_to_start
000396 d020      		rcall	wait_for_low
000397 ff70      		sbrs	flags0, OCT1_PENDING
000398 c00b      		rjmp	run_to_start
000399 dec5      		rcall	wait_OCT1_before_switch
00039a d060      		rcall	com6com1
00039b dea8      		rcall	calc_next_timing
00039c dead      		rcall	wait_OCT1_tot
                 
00039d 20bb      		tst	control_timeout
                 ;		breq	restart_control ; IF COMMENTED: LET MOTORS TURN UNBREAKED TILL UNDER 610RPM
                 
00039e 9100 0066 		lds	temp1, timing_x
0003a0 2300      		tst	temp1
0003a1 f029      		breq	run6_2			; higher than 610 RPM if zero
0003a2 950a      		dec	temp1
0003a3 f019      		breq	run6_2			; higher than 610 RPM if equ 1
0003a4 6290      run_to_start:	sbr	flags2, (1<<STARTUP)
0003a5 7f97      		cbr	flags2, (1<<POFF_CYCLE)
0003a6 cefc      		rjmp	init_startup
                 
0003a7 7f97      run6_2:		cbr	flags2, (1<<POFF_CYCLE)
0003a8 20ff      		tst	run_control		; only once !
0003a9 f041      		breq	run6_9
0003aa 94fa      		dec	run_control
0003ab f029      		breq	run6_3			; poweroff if 0
0003ac 2d0f      		mov	temp1, run_control
0003ad 3001      		cpi	temp1, 1		; poweroff if 1
0003ae f011      		breq	run6_3
0003af 3002      		cpi	temp1, 2		; poweroff if 2
0003b0 f409      		brne	run6_9
0003b1 6098      run6_3:		sbr	flags2, (1<<POFF_CYCLE)
                 
                 run6_9:
0003b2 cfab      		rjmp	run1			; go back to run 1
                 
                 restart_control:
0003b3 ceef      		rjmp	init_startup
0003b4 94f8      		cli				; disable all interrupts
0003b5 ded5      		rcall	switch_power_off
0003b6 cc66      		rjmp	reset
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; *** scan comparator utilities ***
                 ; 
0003b7 ff70      wait_for_low:	sbrs	flags0, OCT1_PENDING
0003b8 9508      		ret
0003b9 9b45      		sbis	ACSR, ACO		; low ?
0003ba cffc      		rjmp	wait_for_low		; .. no - loop, while high
0003bb dedd      		rcall	wait_if_spike		; .. yes - look for a spike
0003bc 9b45      		sbis	ACSR, ACO		; test again
0003bd cff9      		rjmp	wait_for_low		; .. is high again, was a spike
0003be 9508      		ret
                 
0003bf ff70      wait_for_high:	sbrs	flags0, OCT1_PENDING
0003c0 9508      		ret
0003c1 9945      		sbic	ACSR, ACO		; high ?
0003c2 cffc      		rjmp	wait_for_high		; .. no - loop, while low
0003c3 ded5      		rcall	wait_if_spike		; .. yes - look for a spike
0003c4 9945      		sbic	ACSR, ACO		; test again
0003c5 cff9      		rjmp	wait_for_high		; .. is low again, was a spike
0003c6 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 ; *** commutation utilities ***
0003c7 9897      com1com2:	BpFET_off		; Bp off
0003c8 ff80      		sbrs	flags1, POWER_OFF
0003c9 9a95      		ApFET_on		; Ap on
0003ca e003      		ldi	temp1, mux_b		; set comparator multiplexer to phase B
0003cb b907      		out	ADMUX, temp1
0003cc 9508      		ret
                 
0003cd e104      com2com3:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
0003ce bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
0003cf 0000      		nop
0003d0 7d7f      		cbr	flags0, (1<<A_FET)	; next nFET = BnFET
0003d1 7e7f      		cbr	flags0, (1<<C_FET)
0003d2 fd81      		sbrc	flags1, FULL_POWER
0003d3 c002      		rjmp	c2_switch
0003d4 fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
0003d5 c003      		rjmp	c2_done			; .. yes - futhermore work is done in timer0 interrupt
0003d6 9893      c2_switch:	CnFET_off		; Cn off
0003d7 ff80      		sbrs	flags1, POWER_OFF
0003d8 9a91      		BnFET_on		; Bn on
0003d9 e105      c2_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
0003da bf09      		out	TIMSK, temp1
0003db e004      		ldi	temp1, mux_c		; set comparator multiplexer to phase C
0003dc b907      		out	ADMUX, temp1
0003dd 9508      		ret
                 
0003de 9895      com3com4:	ApFET_off		; Ap off
0003df ff80      		sbrs	flags1, POWER_OFF
0003e0 9a94      		CpFET_on		; Cp on
0003e1 e002      		ldi	temp1, mux_a		; set comparator multiplexer to phase A
0003e2 b907      		out	ADMUX, temp1
0003e3 9508      		ret
                 
0003e4 e104      com4com5:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
0003e5 bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
0003e6 0000      		nop
0003e7 6270      		sbr	flags0, (1<<A_FET)	; next nFET = AnFET
0003e8 7e7f      		cbr	flags0, (1<<C_FET)
0003e9 fd81      		sbrc	flags1, FULL_POWER
0003ea c002      		rjmp	c4_switch
0003eb fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
0003ec c003      		rjmp	c4_done			; .. yes - futhermore work is done in timer0 interrupt
0003ed 9891      c4_switch:	BnFET_off		; Bn off
0003ee ff80      		sbrs	flags1, POWER_OFF
0003ef 9aa8      		AnFET_on		; An on
0003f0 e105      c4_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
0003f1 bf09      		out	TIMSK, temp1
0003f2 e003      		ldi	temp1, mux_b		; set comparator multiplexer to phase B
0003f3 b907      		out	ADMUX, temp1
0003f4 9508      		ret
                 
0003f5 9894      com5com6:	CpFET_off		; Cp off
0003f6 ff80      		sbrs	flags1, POWER_OFF
0003f7 9a97      		BpFET_on		; Bp on
0003f8 e004      		ldi	temp1, mux_c		; set comparator multiplexer to phase C
0003f9 b907      		out	ADMUX, temp1
0003fa 9508      		ret
                 
0003fb e104      com6com1:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
0003fc bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
0003fd 0000      		nop
0003fe 7d7f      		cbr	flags0, (1<<A_FET)	; next nFET = CnFET
0003ff 6170      		sbr	flags0, (1<<C_FET)
000400 fd81      		sbrc	flags1, FULL_POWER
000401 c002      		rjmp	c6_switch
000402 fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
000403 c003      		rjmp	c6_done			; .. yes - futhermore work is done in timer0 interrupt
000404 98a8      c6_switch:	AnFET_off		; An off
000405 ff80      		sbrs	flags1, POWER_OFF
000406 9a93      		CnFET_on		; Cn on
000407 e105      c6_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000408 bf09      		out	TIMSK, temp1
000409 e002      		ldi	temp1, mux_a		; set comparator multiplexer to phase A
00040a b907      		out	ADMUX, temp1
00040b 9508      		ret
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   0 r1 :  10 r2 :   7 r3 :   6 r4 :   0 r5 :   2 r6 :   5 r7 :   0 
r8 :   0 r9 :   4 r10:   0 r11:   6 r12:   5 r13:   6 r14:   4 r15:   6 
r16: 207 r17:  46 r18:  50 r19:  39 r20:  25 r21:  13 r22:   0 r23:  54 
r24:  32 r25:  54 r26:   2 r27:   1 r28:  11 r29:  15 r30:  18 r31:   6 
x  :   2 y  :   0 z  :   0 
Registers used: 27 out of 35 (77.1%)

ATmega8 instruction use summary:
adc   :   9 add   :   7 adiw  :   0 and   :   0 andi  :   1 asr   :   0 
bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   7 brcs  :   9 
breq  :  13 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 
brlo  :   2 brlt  :   0 brmi  :   0 brne  :  26 brpl  :   0 brsh  :   2 
brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 
cbi   :  15 cbr   :  23 clc   :   0 clh   :   0 cli   :   2 cln   :   0 
clr   :  11 cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   3 
cp    :   6 cpc   :   0 cpi   :  21 cpse  :   0 dec   :  19 eor   :   0 
fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  18 
inc   :   4 ld    :   1 ldd   :   0 ldi   :  96 lds   :  38 lpm   :   0 
lsl   :   0 lsr   :  11 mov   :  36 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :  12 or    :   0 ori   :   2 out   :  61 
pop   :   0 push  :   0 rcall : 105 ret   :  28 reti  :   5 rjmp  : 123 
rol   :   0 ror   :  16 sbc   :   3 sbci  :   2 sbi   :  15 sbic  :   3 
sbis  :   3 sbiw  :   0 sbr   :  35 sbrc  :  37 sbrs  :  42 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  44 sub   :   5 subi  :   1 swap  :   0 tst   :  15 wdr   :   0 

Instructions used: 46 out of 108 (42.6%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000818   2042     30   2072    8192  25.3%
[.dseg] 0x000060 0x0000e3      0    131    131    1024  12.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
